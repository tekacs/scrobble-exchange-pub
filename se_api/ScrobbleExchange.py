#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:utf8strings,new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def apikey(self, ):
    """
    Returns the SE API key for sending to last.fm
    """
    pass

  def login(self, token):
    """
    If successful, returns the AuthUser with the user session token

    Parameters:
     - token
    """
    pass

  def getArtist(self, artist):
    """
    Returns basic artist info. If either the artist or the mbid is unknown,
    then the empty string should be sent.

    Parameters:
     - artist
    """
    pass

  def getLightArtist(self, artist):
    """
    Returns only MBID and name. If either artist or mbid are unknown, then
    the empty string should be sent

    Parameters:
     - artist
    """
    pass

  def getArtistSE(self, artist, user):
    """
    Returns the data from our db. If the artist isn't there, the data gets
    on-demand pulled. If either artist or mbid are unknown, then the empty
    string should be sent. User sets the `ownedby' bool, by default the
    user name should be an empty string

    Parameters:
     - artist
     - user
    """
    pass

  def getArtistLFM(self, artist):
    """
    Returns the artist info from last.fm for the artist. If either artist
    or mbid are unknown, then the empty string should be sent.

    Parameters:
     - artist
    """
    pass

  def getArtistHistory(self, artist, n):
    """
    Returns a list of tuples of the price of the artist the past n days.
    For new artists the empty list is returned.

    Parameters:
     - artist
     - n
    """
    pass

  def searchArtist(self, text, n, page):
    """
    returns a list of possible artists from a partial string. Ordered by
    decreasing relevance. List size is limited to n elements, and page
    returns the given page of results.

    Parameters:
     - text
     - n
     - page
    """
    pass

  def getSETop(self, n, trange, user):
    """
    Returns a list of the n top SE artists by decreasing value. Trange is
    the number of days the leaderboard is over. User returns relevant
    prices for each artist, otherwise buy price for anonymous users.

    Parameters:
     - n
     - trange
     - user
    """
    pass

  def getLFMTop(self, n, user):
    """
    Returns a list of the n top last.fm artists by decreasing value. User
    returns relevant prices for each artist, otherwise buy price for
    anonymous users

    Parameters:
     - n
     - user
    """
    pass

  def getRecommendedArtists(self, n, user):
    """
    Returns the n top recommended artists for a user. *

    Parameters:
     - n
     - user
    """
    pass

  def getTradedArtists(self, n, user):
    """
    Returns a list of the n most traded artists by decreasing value. User
    returns relevant prices for each artist, otherwise buy price for
    anonymous users.

    Parameters:
     - n
     - user
    """
    pass

  def getRecentTrades(self, n, user):
    """
    Returns a list of the n most recent trades. User returns relevant
    prices for each artist, otherwise buy price for anonymous users.

    Parameters:
     - n
     - user
    """
    pass

  def getUserData(self, user):
    """
    Returns extended user data for the current user.

    Parameters:
     - user
    """
    pass

  def getUserMoney(self, user):
    """
    Returns the current user with money. Requires AuthUser to auth

    Parameters:
     - user
    """
    pass

  def getLeagues(self, ):
    """
    Returns a list of all the leagues that exist in the game
    """
    pass

  def getTopUsers(self, n, league, trange):
    """
    Returns the n top users by decreasing value in the given league. Trange
    is the number of days the leaderboard is over, rounded to the nearest
    day, week or month.

    Parameters:
     - n
     - league
     - trange
    """
    pass

  def getNearUsers(self, user):
    """
    Returns a list of 10 users with 4 above and 5 below in the leaderboard
    compared to the user provided, including the user's position.

    Parameters:
     - user
    """
    pass

  def getGuarantee(self, artist, user):
    """
    Returns the guarantee token (elephant) to the front end

    Parameters:
     - artist
     - user
    """
    pass

  def buy(self, guarantee, user):
    """
    Buys artist for user, and returns a bool as to whether it was
    successful or not

    Parameters:
     - guarantee
     - user
    """
    pass

  def sell(self, guarantee, user):
    """
    Sells artist for user, and returns a bool as to whether it was
    successful or not

    Parameters:
     - guarantee
     - user
    """
    pass

  def reset(self, user):
    """
    Resets the user to the default state.

    Parameters:
     - user
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def apikey(self, ):
    """
    Returns the SE API key for sending to last.fm
    """
    self.send_apikey()
    return self.recv_apikey()

  def send_apikey(self, ):
    self._oprot.writeMessageBegin('apikey', TMessageType.CALL, self._seqid)
    args = apikey_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_apikey(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = apikey_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "apikey failed: unknown result");

  def login(self, token):
    """
    If successful, returns the AuthUser with the user session token

    Parameters:
     - token
    """
    self.send_login(token)
    return self.recv_login()

  def send_login(self, token):
    self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
    args = login_args()
    args.token = token
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_login(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = login_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result");

  def getArtist(self, artist):
    """
    Returns basic artist info. If either the artist or the mbid is unknown,
    then the empty string should be sent.

    Parameters:
     - artist
    """
    self.send_getArtist(artist)
    return self.recv_getArtist()

  def send_getArtist(self, artist):
    self._oprot.writeMessageBegin('getArtist', TMessageType.CALL, self._seqid)
    args = getArtist_args()
    args.artist = artist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtist failed: unknown result");

  def getLightArtist(self, artist):
    """
    Returns only MBID and name. If either artist or mbid are unknown, then
    the empty string should be sent

    Parameters:
     - artist
    """
    self.send_getLightArtist(artist)
    return self.recv_getLightArtist()

  def send_getLightArtist(self, artist):
    self._oprot.writeMessageBegin('getLightArtist', TMessageType.CALL, self._seqid)
    args = getLightArtist_args()
    args.artist = artist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLightArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLightArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLightArtist failed: unknown result");

  def getArtistSE(self, artist, user):
    """
    Returns the data from our db. If the artist isn't there, the data gets
    on-demand pulled. If either artist or mbid are unknown, then the empty
    string should be sent. User sets the `ownedby' bool, by default the
    user name should be an empty string

    Parameters:
     - artist
     - user
    """
    self.send_getArtistSE(artist, user)
    return self.recv_getArtistSE()

  def send_getArtistSE(self, artist, user):
    self._oprot.writeMessageBegin('getArtistSE', TMessageType.CALL, self._seqid)
    args = getArtistSE_args()
    args.artist = artist
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtistSE(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtistSE_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtistSE failed: unknown result");

  def getArtistLFM(self, artist):
    """
    Returns the artist info from last.fm for the artist. If either artist
    or mbid are unknown, then the empty string should be sent.

    Parameters:
     - artist
    """
    self.send_getArtistLFM(artist)
    return self.recv_getArtistLFM()

  def send_getArtistLFM(self, artist):
    self._oprot.writeMessageBegin('getArtistLFM', TMessageType.CALL, self._seqid)
    args = getArtistLFM_args()
    args.artist = artist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtistLFM(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtistLFM_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtistLFM failed: unknown result");

  def getArtistHistory(self, artist, n):
    """
    Returns a list of tuples of the price of the artist the past n days.
    For new artists the empty list is returned.

    Parameters:
     - artist
     - n
    """
    self.send_getArtistHistory(artist, n)
    return self.recv_getArtistHistory()

  def send_getArtistHistory(self, artist, n):
    self._oprot.writeMessageBegin('getArtistHistory', TMessageType.CALL, self._seqid)
    args = getArtistHistory_args()
    args.artist = artist
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtistHistory(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtistHistory_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtistHistory failed: unknown result");

  def searchArtist(self, text, n, page):
    """
    returns a list of possible artists from a partial string. Ordered by
    decreasing relevance. List size is limited to n elements, and page
    returns the given page of results.

    Parameters:
     - text
     - n
     - page
    """
    self.send_searchArtist(text, n, page)
    return self.recv_searchArtist()

  def send_searchArtist(self, text, n, page):
    self._oprot.writeMessageBegin('searchArtist', TMessageType.CALL, self._seqid)
    args = searchArtist_args()
    args.text = text
    args.n = n
    args.page = page
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_searchArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = searchArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "searchArtist failed: unknown result");

  def getSETop(self, n, trange, user):
    """
    Returns a list of the n top SE artists by decreasing value. Trange is
    the number of days the leaderboard is over. User returns relevant
    prices for each artist, otherwise buy price for anonymous users.

    Parameters:
     - n
     - trange
     - user
    """
    self.send_getSETop(n, trange, user)
    return self.recv_getSETop()

  def send_getSETop(self, n, trange, user):
    self._oprot.writeMessageBegin('getSETop', TMessageType.CALL, self._seqid)
    args = getSETop_args()
    args.n = n
    args.trange = trange
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSETop(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSETop_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSETop failed: unknown result");

  def getLFMTop(self, n, user):
    """
    Returns a list of the n top last.fm artists by decreasing value. User
    returns relevant prices for each artist, otherwise buy price for
    anonymous users

    Parameters:
     - n
     - user
    """
    self.send_getLFMTop(n, user)
    return self.recv_getLFMTop()

  def send_getLFMTop(self, n, user):
    self._oprot.writeMessageBegin('getLFMTop', TMessageType.CALL, self._seqid)
    args = getLFMTop_args()
    args.n = n
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLFMTop(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLFMTop_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLFMTop failed: unknown result");

  def getRecommendedArtists(self, n, user):
    """
    Returns the n top recommended artists for a user. *

    Parameters:
     - n
     - user
    """
    self.send_getRecommendedArtists(n, user)
    return self.recv_getRecommendedArtists()

  def send_getRecommendedArtists(self, n, user):
    self._oprot.writeMessageBegin('getRecommendedArtists', TMessageType.CALL, self._seqid)
    args = getRecommendedArtists_args()
    args.n = n
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRecommendedArtists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRecommendedArtists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRecommendedArtists failed: unknown result");

  def getTradedArtists(self, n, user):
    """
    Returns a list of the n most traded artists by decreasing value. User
    returns relevant prices for each artist, otherwise buy price for
    anonymous users.

    Parameters:
     - n
     - user
    """
    self.send_getTradedArtists(n, user)
    return self.recv_getTradedArtists()

  def send_getTradedArtists(self, n, user):
    self._oprot.writeMessageBegin('getTradedArtists', TMessageType.CALL, self._seqid)
    args = getTradedArtists_args()
    args.n = n
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTradedArtists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTradedArtists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTradedArtists failed: unknown result");

  def getRecentTrades(self, n, user):
    """
    Returns a list of the n most recent trades. User returns relevant
    prices for each artist, otherwise buy price for anonymous users.

    Parameters:
     - n
     - user
    """
    self.send_getRecentTrades(n, user)
    return self.recv_getRecentTrades()

  def send_getRecentTrades(self, n, user):
    self._oprot.writeMessageBegin('getRecentTrades', TMessageType.CALL, self._seqid)
    args = getRecentTrades_args()
    args.n = n
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRecentTrades(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRecentTrades_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRecentTrades failed: unknown result");

  def getUserData(self, user):
    """
    Returns extended user data for the current user.

    Parameters:
     - user
    """
    self.send_getUserData(user)
    return self.recv_getUserData()

  def send_getUserData(self, user):
    self._oprot.writeMessageBegin('getUserData', TMessageType.CALL, self._seqid)
    args = getUserData_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUserData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUserData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserData failed: unknown result");

  def getUserMoney(self, user):
    """
    Returns the current user with money. Requires AuthUser to auth

    Parameters:
     - user
    """
    self.send_getUserMoney(user)
    return self.recv_getUserMoney()

  def send_getUserMoney(self, user):
    self._oprot.writeMessageBegin('getUserMoney', TMessageType.CALL, self._seqid)
    args = getUserMoney_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUserMoney(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUserMoney_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    if result.a is not None:
      raise result.a
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserMoney failed: unknown result");

  def getLeagues(self, ):
    """
    Returns a list of all the leagues that exist in the game
    """
    self.send_getLeagues()
    return self.recv_getLeagues()

  def send_getLeagues(self, ):
    self._oprot.writeMessageBegin('getLeagues', TMessageType.CALL, self._seqid)
    args = getLeagues_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLeagues(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLeagues_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLeagues failed: unknown result");

  def getTopUsers(self, n, league, trange):
    """
    Returns the n top users by decreasing value in the given league. Trange
    is the number of days the leaderboard is over, rounded to the nearest
    day, week or month.

    Parameters:
     - n
     - league
     - trange
    """
    self.send_getTopUsers(n, league, trange)
    return self.recv_getTopUsers()

  def send_getTopUsers(self, n, league, trange):
    self._oprot.writeMessageBegin('getTopUsers', TMessageType.CALL, self._seqid)
    args = getTopUsers_args()
    args.n = n
    args.league = league
    args.trange = trange
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTopUsers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTopUsers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTopUsers failed: unknown result");

  def getNearUsers(self, user):
    """
    Returns a list of 10 users with 4 above and 5 below in the leaderboard
    compared to the user provided, including the user's position.

    Parameters:
     - user
    """
    self.send_getNearUsers(user)
    return self.recv_getNearUsers()

  def send_getNearUsers(self, user):
    self._oprot.writeMessageBegin('getNearUsers', TMessageType.CALL, self._seqid)
    args = getNearUsers_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNearUsers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNearUsers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNearUsers failed: unknown result");

  def getGuarantee(self, artist, user):
    """
    Returns the guarantee token (elephant) to the front end

    Parameters:
     - artist
     - user
    """
    self.send_getGuarantee(artist, user)
    return self.recv_getGuarantee()

  def send_getGuarantee(self, artist, user):
    self._oprot.writeMessageBegin('getGuarantee', TMessageType.CALL, self._seqid)
    args = getGuarantee_args()
    args.artist = artist
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGuarantee(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGuarantee_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGuarantee failed: unknown result");

  def buy(self, guarantee, user):
    """
    Buys artist for user, and returns a bool as to whether it was
    successful or not

    Parameters:
     - guarantee
     - user
    """
    self.send_buy(guarantee, user)
    return self.recv_buy()

  def send_buy(self, guarantee, user):
    self._oprot.writeMessageBegin('buy', TMessageType.CALL, self._seqid)
    args = buy_args()
    args.guarantee = guarantee
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_buy(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = buy_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    raise TApplicationException(TApplicationException.MISSING_RESULT, "buy failed: unknown result");

  def sell(self, guarantee, user):
    """
    Sells artist for user, and returns a bool as to whether it was
    successful or not

    Parameters:
     - guarantee
     - user
    """
    self.send_sell(guarantee, user)
    return self.recv_sell()

  def send_sell(self, guarantee, user):
    self._oprot.writeMessageBegin('sell', TMessageType.CALL, self._seqid)
    args = sell_args()
    args.guarantee = guarantee
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sell(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sell_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sell failed: unknown result");

  def reset(self, user):
    """
    Resets the user to the default state.

    Parameters:
     - user
    """
    self.send_reset(user)
    return self.recv_reset()

  def send_reset(self, user):
    self._oprot.writeMessageBegin('reset', TMessageType.CALL, self._seqid)
    args = reset_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_reset(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = reset_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.a is not None:
      raise result.a
    raise TApplicationException(TApplicationException.MISSING_RESULT, "reset failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["apikey"] = Processor.process_apikey
    self._processMap["login"] = Processor.process_login
    self._processMap["getArtist"] = Processor.process_getArtist
    self._processMap["getLightArtist"] = Processor.process_getLightArtist
    self._processMap["getArtistSE"] = Processor.process_getArtistSE
    self._processMap["getArtistLFM"] = Processor.process_getArtistLFM
    self._processMap["getArtistHistory"] = Processor.process_getArtistHistory
    self._processMap["searchArtist"] = Processor.process_searchArtist
    self._processMap["getSETop"] = Processor.process_getSETop
    self._processMap["getLFMTop"] = Processor.process_getLFMTop
    self._processMap["getRecommendedArtists"] = Processor.process_getRecommendedArtists
    self._processMap["getTradedArtists"] = Processor.process_getTradedArtists
    self._processMap["getRecentTrades"] = Processor.process_getRecentTrades
    self._processMap["getUserData"] = Processor.process_getUserData
    self._processMap["getUserMoney"] = Processor.process_getUserMoney
    self._processMap["getLeagues"] = Processor.process_getLeagues
    self._processMap["getTopUsers"] = Processor.process_getTopUsers
    self._processMap["getNearUsers"] = Processor.process_getNearUsers
    self._processMap["getGuarantee"] = Processor.process_getGuarantee
    self._processMap["buy"] = Processor.process_buy
    self._processMap["sell"] = Processor.process_sell
    self._processMap["reset"] = Processor.process_reset

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_apikey(self, seqid, iprot, oprot):
    args = apikey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = apikey_result()
    result.success = self._handler.apikey()
    oprot.writeMessageBegin("apikey", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_login(self, seqid, iprot, oprot):
    args = login_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = login_result()
    try:
      result.success = self._handler.login(args.token)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("login", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtist(self, seqid, iprot, oprot):
    args = getArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtist_result()
    try:
      result.success = self._handler.getArtist(args.artist)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLightArtist(self, seqid, iprot, oprot):
    args = getLightArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLightArtist_result()
    try:
      result.success = self._handler.getLightArtist(args.artist)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getLightArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtistSE(self, seqid, iprot, oprot):
    args = getArtistSE_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtistSE_result()
    try:
      result.success = self._handler.getArtistSE(args.artist, args.user)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getArtistSE", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtistLFM(self, seqid, iprot, oprot):
    args = getArtistLFM_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtistLFM_result()
    try:
      result.success = self._handler.getArtistLFM(args.artist)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getArtistLFM", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtistHistory(self, seqid, iprot, oprot):
    args = getArtistHistory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtistHistory_result()
    try:
      result.success = self._handler.getArtistHistory(args.artist, args.n)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getArtistHistory", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_searchArtist(self, seqid, iprot, oprot):
    args = searchArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = searchArtist_result()
    try:
      result.success = self._handler.searchArtist(args.text, args.n, args.page)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("searchArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSETop(self, seqid, iprot, oprot):
    args = getSETop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSETop_result()
    try:
      result.success = self._handler.getSETop(args.n, args.trange, args.user)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getSETop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLFMTop(self, seqid, iprot, oprot):
    args = getLFMTop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLFMTop_result()
    try:
      result.success = self._handler.getLFMTop(args.n, args.user)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getLFMTop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRecommendedArtists(self, seqid, iprot, oprot):
    args = getRecommendedArtists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRecommendedArtists_result()
    try:
      result.success = self._handler.getRecommendedArtists(args.n, args.user)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getRecommendedArtists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTradedArtists(self, seqid, iprot, oprot):
    args = getTradedArtists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTradedArtists_result()
    try:
      result.success = self._handler.getTradedArtists(args.n, args.user)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getTradedArtists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRecentTrades(self, seqid, iprot, oprot):
    args = getRecentTrades_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRecentTrades_result()
    try:
      result.success = self._handler.getRecentTrades(args.n, args.user)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getRecentTrades", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUserData(self, seqid, iprot, oprot):
    args = getUserData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserData_result()
    try:
      result.success = self._handler.getUserData(args.user)
    except DataError as d:
      result.d = d
    oprot.writeMessageBegin("getUserData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUserMoney(self, seqid, iprot, oprot):
    args = getUserMoney_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserMoney_result()
    try:
      result.success = self._handler.getUserMoney(args.user)
    except DataError as d:
      result.d = d
    except AuthenticationError as a:
      result.a = a
    oprot.writeMessageBegin("getUserMoney", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLeagues(self, seqid, iprot, oprot):
    args = getLeagues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLeagues_result()
    try:
      result.success = self._handler.getLeagues()
    except DataError as d:
      result.d = d
    oprot.writeMessageBegin("getLeagues", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTopUsers(self, seqid, iprot, oprot):
    args = getTopUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTopUsers_result()
    try:
      result.success = self._handler.getTopUsers(args.n, args.league, args.trange)
    except DataError as d:
      result.d = d
    oprot.writeMessageBegin("getTopUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNearUsers(self, seqid, iprot, oprot):
    args = getNearUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNearUsers_result()
    try:
      result.success = self._handler.getNearUsers(args.user)
    except DataError as d:
      result.d = d
    oprot.writeMessageBegin("getNearUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGuarantee(self, seqid, iprot, oprot):
    args = getGuarantee_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGuarantee_result()
    try:
      result.success = self._handler.getGuarantee(args.artist, args.user)
    except DataError as d:
      result.d = d
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    oprot.writeMessageBegin("getGuarantee", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_buy(self, seqid, iprot, oprot):
    args = buy_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = buy_result()
    try:
      result.success = self._handler.buy(args.guarantee, args.user)
    except DataError as d:
      result.d = d
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    oprot.writeMessageBegin("buy", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sell(self, seqid, iprot, oprot):
    args = sell_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sell_result()
    try:
      result.success = self._handler.sell(args.guarantee, args.user)
    except DataError as d:
      result.d = d
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    oprot.writeMessageBegin("sell", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_reset(self, seqid, iprot, oprot):
    args = reset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = reset_result()
    try:
      result.success = self._handler.reset(args.user)
    except AuthenticationError as a:
      result.a = a
    oprot.writeMessageBegin("reset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class apikey_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('apikey_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class apikey_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('apikey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_args(object):
  """
  Attributes:
   - token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
  )

  def __init__(self, token=None,):
    self.token = token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthUser, AuthUser.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthUser()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtist_args(object):
  """
  Attributes:
   - artist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
  )

  def __init__(self, artist=None,):
    self.artist = artist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtist_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtist_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Artist, Artist.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Artist()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLightArtist_args(object):
  """
  Attributes:
   - artist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
  )

  def __init__(self, artist=None,):
    self.artist = artist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLightArtist_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLightArtist_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Artist, Artist.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Artist()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLightArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistSE_args(object):
  """
  Attributes:
   - artist
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, artist=None, user=None,):
    self.artist = artist
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistSE_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistSE_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ArtistSE, ArtistSE.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ArtistSE()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistSE_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistLFM_args(object):
  """
  Attributes:
   - artist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
  )

  def __init__(self, artist=None,):
    self.artist = artist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistLFM_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistLFM_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ArtistLFM, ArtistLFM.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ArtistLFM()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistLFM_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistHistory_args(object):
  """
  Attributes:
   - artist
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
    (2, TType.I32, 'n', None, None, ), # 2
  )

  def __init__(self, artist=None, n=None,):
    self.artist = artist
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistHistory_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 2)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistHistory_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ArtistHistory, ArtistHistory.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ArtistHistory()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistHistory_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchArtist_args(object):
  """
  Attributes:
   - text
   - n
   - page
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.I32, 'n', None, None, ), # 2
    (3, TType.I32, 'page', None, None, ), # 3
  )

  def __init__(self, text=None, n=None, page=None,):
    self.text = text
    self.n = n
    self.page = page

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.page = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchArtist_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 2)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.page is not None:
      oprot.writeFieldBegin('page', TType.I32, 3)
      oprot.writeI32(self.page)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.text is None:
      raise TProtocol.TProtocolException(message='Required field text is unset!')
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.page is None:
      raise TProtocol.TProtocolException(message='Required field page is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchArtist_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Artist, Artist.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype90, _size87) = iprot.readListBegin()
          for _i91 in xrange(_size87):
            _elem92 = Artist()
            _elem92.read(iprot)
            self.success.append(_elem92)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter93 in self.success:
        iter93.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSETop_args(object):
  """
  Attributes:
   - n
   - trange
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.I32, 'trange', None, None, ), # 2
    (3, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 3
  )

  def __init__(self, n=None, trange=None, user=None,):
    self.n = n
    self.trange = trange
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.trange = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSETop_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.trange is not None:
      oprot.writeFieldBegin('trange', TType.I32, 2)
      oprot.writeI32(self.trange)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 3)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.trange is None:
      raise TProtocol.TProtocolException(message='Required field trange is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSETop_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ArtistSE, ArtistSE.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype97, _size94) = iprot.readListBegin()
          for _i98 in xrange(_size94):
            _elem99 = ArtistSE()
            _elem99.read(iprot)
            self.success.append(_elem99)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSETop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter100 in self.success:
        iter100.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLFMTop_args(object):
  """
  Attributes:
   - n
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, n=None, user=None,):
    self.n = n
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLFMTop_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLFMTop_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ArtistSE, ArtistSE.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype104, _size101) = iprot.readListBegin()
          for _i105 in xrange(_size101):
            _elem106 = ArtistSE()
            _elem106.read(iprot)
            self.success.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLFMTop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter107 in self.success:
        iter107.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecommendedArtists_args(object):
  """
  Attributes:
   - n
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 2
  )

  def __init__(self, n=None, user=None,):
    self.n = n
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecommendedArtists_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecommendedArtists_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ArtistSE, ArtistSE.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype111, _size108) = iprot.readListBegin()
          for _i112 in xrange(_size108):
            _elem113 = ArtistSE()
            _elem113.read(iprot)
            self.success.append(_elem113)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecommendedArtists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter114 in self.success:
        iter114.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTradedArtists_args(object):
  """
  Attributes:
   - n
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, n=None, user=None,):
    self.n = n
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTradedArtists_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTradedArtists_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ArtistSE, ArtistSE.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype118, _size115) = iprot.readListBegin()
          for _i119 in xrange(_size115):
            _elem120 = ArtistSE()
            _elem120.read(iprot)
            self.success.append(_elem120)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTradedArtists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter121 in self.success:
        iter121.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecentTrades_args(object):
  """
  Attributes:
   - n
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, n=None, user=None,):
    self.n = n
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecentTrades_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecentTrades_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ArtistSE, ArtistSE.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype125, _size122) = iprot.readListBegin()
          for _i126 in xrange(_size122):
            _elem127 = ArtistSE()
            _elem127.read(iprot)
            self.success.append(_elem127)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecentTrades_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter128 in self.success:
        iter128.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserData_args(object):
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user', None, None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserData_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserData_result(object):
  """
  Attributes:
   - success
   - d
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserData, UserData.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, d=None,):
    self.success = success
    self.d = d

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserData()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserMoney_args(object):
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserMoney_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 1)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserMoney_result(object):
  """
  Attributes:
   - success
   - d
   - a
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthUser, AuthUser.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, d=None, a=None,):
    self.success = success
    self.d = d
    self.a = a

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthUser()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserMoney_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLeagues_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLeagues_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLeagues_result(object):
  """
  Attributes:
   - success
   - d
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(League, League.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, d=None,):
    self.success = success
    self.d = d

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype132, _size129) = iprot.readListBegin()
          for _i133 in xrange(_size129):
            _elem134 = League()
            _elem134.read(iprot)
            self.success.append(_elem134)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLeagues_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter135 in self.success:
        iter135.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopUsers_args(object):
  """
  Attributes:
   - n
   - league
   - trange
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.STRUCT, 'league', (League, League.thrift_spec), None, ), # 2
    (3, TType.I32, 'trange', None, None, ), # 3
  )

  def __init__(self, n=None, league=None, trange=None,):
    self.n = n
    self.league = league
    self.trange = trange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.league = League()
          self.league.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.trange = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopUsers_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.league is not None:
      oprot.writeFieldBegin('league', TType.STRUCT, 2)
      self.league.write(oprot)
      oprot.writeFieldEnd()
    if self.trange is not None:
      oprot.writeFieldBegin('trange', TType.I32, 3)
      oprot.writeI32(self.trange)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.league is None:
      raise TProtocol.TProtocolException(message='Required field league is unset!')
    if self.trange is None:
      raise TProtocol.TProtocolException(message='Required field trange is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopUsers_result(object):
  """
  Attributes:
   - success
   - d
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserLeaderboard, UserLeaderboard.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, d=None,):
    self.success = success
    self.d = d

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserLeaderboard()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNearUsers_args(object):
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user', None, None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNearUsers_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNearUsers_result(object):
  """
  Attributes:
   - success
   - d
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserLeaderboard, UserLeaderboard.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, d=None,):
    self.success = success
    self.d = d

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserLeaderboard()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNearUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGuarantee_args(object):
  """
  Attributes:
   - artist
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 2
  )

  def __init__(self, artist=None, user=None,):
    self.artist = artist
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGuarantee_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGuarantee_result(object):
  """
  Attributes:
   - success
   - d
   - t
   - a
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Guarantee, Guarantee.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, d=None, t=None, a=None,):
    self.success = success
    self.d = d
    self.t = t
    self.a = a

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Guarantee()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGuarantee_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 2)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 3)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class buy_args(object):
  """
  Attributes:
   - guarantee
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'guarantee', (Guarantee, Guarantee.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 2
  )

  def __init__(self, guarantee=None, user=None,):
    self.guarantee = guarantee
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.guarantee = Guarantee()
          self.guarantee.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('buy_args')
    if self.guarantee is not None:
      oprot.writeFieldBegin('guarantee', TType.STRUCT, 1)
      self.guarantee.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.guarantee is None:
      raise TProtocol.TProtocolException(message='Required field guarantee is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class buy_result(object):
  """
  Attributes:
   - success
   - d
   - t
   - a
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, d=None, t=None, a=None,):
    self.success = success
    self.d = d
    self.t = t
    self.a = a

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('buy_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 2)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 3)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sell_args(object):
  """
  Attributes:
   - guarantee
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'guarantee', (Guarantee, Guarantee.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 2
  )

  def __init__(self, guarantee=None, user=None,):
    self.guarantee = guarantee
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.guarantee = Guarantee()
          self.guarantee.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sell_args')
    if self.guarantee is not None:
      oprot.writeFieldBegin('guarantee', TType.STRUCT, 1)
      self.guarantee.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.guarantee is None:
      raise TProtocol.TProtocolException(message='Required field guarantee is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sell_result(object):
  """
  Attributes:
   - success
   - d
   - t
   - a
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, d=None, t=None, a=None,):
    self.success = success
    self.d = d
    self.t = t
    self.a = a

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sell_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 2)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 3)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reset_args(object):
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reset_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 1)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reset_result(object):
  """
  Attributes:
   - success
   - a
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, a=None,):
    self.success = success
    self.a = a

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reset_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 1)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

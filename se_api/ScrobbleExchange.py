#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def apikey(self, ):
    """
    Returns the SE API key for sending to last.fm
    """
    pass

  def login(self, token):
    """
    If successful, returns the AuthUser with the user session token

    Parameters:
     - token
    """
    pass

  def getArtist(self, artist):
    """
    Returns basic artist info. If either the artist or the mbid is unknown,
    then the empty string should be sent.

    Parameters:
     - artist
    """
    pass

  def getLightArtist(self, artist):
    """
    Returns only MBID and name. If either artist or mbid are unknown, then
    the empty string should be sent

    Parameters:
     - artist
    """
    pass

  def getArtistSE(self, artist, user):
    """
    Returns the data from our db. If the artist isn't there, the data gets
    on-demand pulled. If either artist or mbid are unknown, then the empty
    string should be sent. User sets the `ownedby' bool, by default it
    should be an empty string the name

    Parameters:
     - artist
     - user
    """
    pass

  def getArtistLFM(self, artist, user):
    """
    Returns the artist info from last.fm for the artist. If either artist
    or mbid are unknown, then the empty string should be sent. An
    authenticated user is required to return recommended artists, otherwise
    the parameter should be set to none

    Parameters:
     - artist
     - user
    """
    pass

  def getArtistHistory(self, artist, n):
    """
    Returns a list of tuples of the price of the artist the past n days.
    For new artists the empty list is returned.

    Parameters:
     - artist
     - n
    """
    pass

  def searchArtist(self, text, n, page):
    """
    returns a list of possible artists from a partial string. Ordered by
    decreasing relevance. List size is limited to n elements, and page
    returns the given page of results

    Parameters:
     - text
     - n
     - page
    """
    pass

  def getSETop(self, n, trange):
    """
    Returns a list of the n top SE artists by decreasing value. Trange is
    the number of days the leaderboard is over

    Parameters:
     - n
     - trange
    """
    pass

  def getLFMTop(self, n):
    """
    Returns a list of the n top last.fm artists by decreasing value.

    Parameters:
     - n
    """
    pass

  def getTradedArtists(self, n):
    """
    Returns a list of the n most traded artists by decreasing value.

    Parameters:
     - n
    """
    pass

  def getRecentTrades(self, n):
    """
    Returns a list of the n most recent trades

    Parameters:
     - n
    """
    pass

  def getUserData(self, user):
    """
    Returns extended user data for the current user.

    Parameters:
     - user
    """
    pass

  def getUserMoney(self, user):
    """
    Returns the current user with money. Requires AuthUser to auth

    Parameters:
     - user
    """
    pass

  def getTopUsers(self, n, league, trange):
    """
    Returns the n top users by decreasing value in the given league. Trange
    is the number of days the leaderboard is over, rounded to the nearest
    day, week or month.

    Parameters:
     - n
     - league
     - trange
    """
    pass

  def getNearUsers(self, user):
    """
    Returns a list of 10 users with 4 above and 5 below in the leaderboard
    compared to the user provided, including the user's position.

    Parameters:
     - user
    """
    pass

  def getGuarantee(self, artist, user):
    """
    Returns the guarantee token (elephant) to the front end

    Parameters:
     - artist
     - user
    """
    pass

  def buy(self, guarantee, user):
    """
    Buys artist for user, and returns a bool as to whether it was
    successful or not

    Parameters:
     - guarantee
     - user
    """
    pass

  def sell(self, guarantee, user):
    """
    Sells artist for user, and returns a bool as to whether it was
    successful or not

    Parameters:
     - guarantee
     - user
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def apikey(self, ):
    """
    Returns the SE API key for sending to last.fm
    """
    self.send_apikey()
    return self.recv_apikey()

  def send_apikey(self, ):
    self._oprot.writeMessageBegin('apikey', TMessageType.CALL, self._seqid)
    args = apikey_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_apikey(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = apikey_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "apikey failed: unknown result");

  def login(self, token):
    """
    If successful, returns the AuthUser with the user session token

    Parameters:
     - token
    """
    self.send_login(token)
    return self.recv_login()

  def send_login(self, token):
    self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
    args = login_args()
    args.token = token
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_login(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = login_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result");

  def getArtist(self, artist):
    """
    Returns basic artist info. If either the artist or the mbid is unknown,
    then the empty string should be sent.

    Parameters:
     - artist
    """
    self.send_getArtist(artist)
    return self.recv_getArtist()

  def send_getArtist(self, artist):
    self._oprot.writeMessageBegin('getArtist', TMessageType.CALL, self._seqid)
    args = getArtist_args()
    args.artist = artist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtist failed: unknown result");

  def getLightArtist(self, artist):
    """
    Returns only MBID and name. If either artist or mbid are unknown, then
    the empty string should be sent

    Parameters:
     - artist
    """
    self.send_getLightArtist(artist)
    return self.recv_getLightArtist()

  def send_getLightArtist(self, artist):
    self._oprot.writeMessageBegin('getLightArtist', TMessageType.CALL, self._seqid)
    args = getLightArtist_args()
    args.artist = artist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLightArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLightArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLightArtist failed: unknown result");

  def getArtistSE(self, artist, user):
    """
    Returns the data from our db. If the artist isn't there, the data gets
    on-demand pulled. If either artist or mbid are unknown, then the empty
    string should be sent. User sets the `ownedby' bool, by default it
    should be an empty string the name

    Parameters:
     - artist
     - user
    """
    self.send_getArtistSE(artist, user)
    return self.recv_getArtistSE()

  def send_getArtistSE(self, artist, user):
    self._oprot.writeMessageBegin('getArtistSE', TMessageType.CALL, self._seqid)
    args = getArtistSE_args()
    args.artist = artist
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtistSE(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtistSE_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtistSE failed: unknown result");

  def getArtistLFM(self, artist, user):
    """
    Returns the artist info from last.fm for the artist. If either artist
    or mbid are unknown, then the empty string should be sent. An
    authenticated user is required to return recommended artists, otherwise
    the parameter should be set to none

    Parameters:
     - artist
     - user
    """
    self.send_getArtistLFM(artist, user)
    return self.recv_getArtistLFM()

  def send_getArtistLFM(self, artist, user):
    self._oprot.writeMessageBegin('getArtistLFM', TMessageType.CALL, self._seqid)
    args = getArtistLFM_args()
    args.artist = artist
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtistLFM(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtistLFM_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtistLFM failed: unknown result");

  def getArtistHistory(self, artist, n):
    """
    Returns a list of tuples of the price of the artist the past n days.
    For new artists the empty list is returned.

    Parameters:
     - artist
     - n
    """
    self.send_getArtistHistory(artist, n)
    return self.recv_getArtistHistory()

  def send_getArtistHistory(self, artist, n):
    self._oprot.writeMessageBegin('getArtistHistory', TMessageType.CALL, self._seqid)
    args = getArtistHistory_args()
    args.artist = artist
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtistHistory(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtistHistory_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtistHistory failed: unknown result");

  def searchArtist(self, text, n, page):
    """
    returns a list of possible artists from a partial string. Ordered by
    decreasing relevance. List size is limited to n elements, and page
    returns the given page of results

    Parameters:
     - text
     - n
     - page
    """
    self.send_searchArtist(text, n, page)
    return self.recv_searchArtist()

  def send_searchArtist(self, text, n, page):
    self._oprot.writeMessageBegin('searchArtist', TMessageType.CALL, self._seqid)
    args = searchArtist_args()
    args.text = text
    args.n = n
    args.page = page
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_searchArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = searchArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "searchArtist failed: unknown result");

  def getSETop(self, n, trange):
    """
    Returns a list of the n top SE artists by decreasing value. Trange is
    the number of days the leaderboard is over

    Parameters:
     - n
     - trange
    """
    self.send_getSETop(n, trange)
    return self.recv_getSETop()

  def send_getSETop(self, n, trange):
    self._oprot.writeMessageBegin('getSETop', TMessageType.CALL, self._seqid)
    args = getSETop_args()
    args.n = n
    args.trange = trange
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSETop(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSETop_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSETop failed: unknown result");

  def getLFMTop(self, n):
    """
    Returns a list of the n top last.fm artists by decreasing value.

    Parameters:
     - n
    """
    self.send_getLFMTop(n)
    return self.recv_getLFMTop()

  def send_getLFMTop(self, n):
    self._oprot.writeMessageBegin('getLFMTop', TMessageType.CALL, self._seqid)
    args = getLFMTop_args()
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLFMTop(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLFMTop_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLFMTop failed: unknown result");

  def getTradedArtists(self, n):
    """
    Returns a list of the n most traded artists by decreasing value.

    Parameters:
     - n
    """
    self.send_getTradedArtists(n)
    return self.recv_getTradedArtists()

  def send_getTradedArtists(self, n):
    self._oprot.writeMessageBegin('getTradedArtists', TMessageType.CALL, self._seqid)
    args = getTradedArtists_args()
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTradedArtists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTradedArtists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTradedArtists failed: unknown result");

  def getRecentTrades(self, n):
    """
    Returns a list of the n most recent trades

    Parameters:
     - n
    """
    self.send_getRecentTrades(n)
    return self.recv_getRecentTrades()

  def send_getRecentTrades(self, n):
    self._oprot.writeMessageBegin('getRecentTrades', TMessageType.CALL, self._seqid)
    args = getRecentTrades_args()
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRecentTrades(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRecentTrades_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.t is not None:
      raise result.t
    if result.a is not None:
      raise result.a
    if result.d is not None:
      raise result.d
    if result.p is not None:
      raise result.p
    if result.s is not None:
      raise result.s
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRecentTrades failed: unknown result");

  def getUserData(self, user):
    """
    Returns extended user data for the current user.

    Parameters:
     - user
    """
    self.send_getUserData(user)
    return self.recv_getUserData()

  def send_getUserData(self, user):
    self._oprot.writeMessageBegin('getUserData', TMessageType.CALL, self._seqid)
    args = getUserData_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUserData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUserData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserData failed: unknown result");

  def getUserMoney(self, user):
    """
    Returns the current user with money. Requires AuthUser to auth

    Parameters:
     - user
    """
    self.send_getUserMoney(user)
    return self.recv_getUserMoney()

  def send_getUserMoney(self, user):
    self._oprot.writeMessageBegin('getUserMoney', TMessageType.CALL, self._seqid)
    args = getUserMoney_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUserMoney(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUserMoney_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserMoney failed: unknown result");

  def getTopUsers(self, n, league, trange):
    """
    Returns the n top users by decreasing value in the given league. Trange
    is the number of days the leaderboard is over, rounded to the nearest
    day, week or month.

    Parameters:
     - n
     - league
     - trange
    """
    self.send_getTopUsers(n, league, trange)
    return self.recv_getTopUsers()

  def send_getTopUsers(self, n, league, trange):
    self._oprot.writeMessageBegin('getTopUsers', TMessageType.CALL, self._seqid)
    args = getTopUsers_args()
    args.n = n
    args.league = league
    args.trange = trange
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTopUsers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTopUsers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTopUsers failed: unknown result");

  def getNearUsers(self, user):
    """
    Returns a list of 10 users with 4 above and 5 below in the leaderboard
    compared to the user provided, including the user's position.

    Parameters:
     - user
    """
    self.send_getNearUsers(user)
    return self.recv_getNearUsers()

  def send_getNearUsers(self, user):
    self._oprot.writeMessageBegin('getNearUsers', TMessageType.CALL, self._seqid)
    args = getNearUsers_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNearUsers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNearUsers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNearUsers failed: unknown result");

  def getGuarantee(self, artist, user):
    """
    Returns the guarantee token (elephant) to the front end

    Parameters:
     - artist
     - user
    """
    self.send_getGuarantee(artist, user)
    return self.recv_getGuarantee()

  def send_getGuarantee(self, artist, user):
    self._oprot.writeMessageBegin('getGuarantee', TMessageType.CALL, self._seqid)
    args = getGuarantee_args()
    args.artist = artist
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGuarantee(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGuarantee_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    if result.t is not None:
      raise result.t
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGuarantee failed: unknown result");

  def buy(self, guarantee, user):
    """
    Buys artist for user, and returns a bool as to whether it was
    successful or not

    Parameters:
     - guarantee
     - user
    """
    self.send_buy(guarantee, user)
    return self.recv_buy()

  def send_buy(self, guarantee, user):
    self._oprot.writeMessageBegin('buy', TMessageType.CALL, self._seqid)
    args = buy_args()
    args.guarantee = guarantee
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_buy(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = buy_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    if result.t is not None:
      raise result.t
    raise TApplicationException(TApplicationException.MISSING_RESULT, "buy failed: unknown result");

  def sell(self, guarantee, user):
    """
    Sells artist for user, and returns a bool as to whether it was
    successful or not

    Parameters:
     - guarantee
     - user
    """
    self.send_sell(guarantee, user)
    return self.recv_sell()

  def send_sell(self, guarantee, user):
    self._oprot.writeMessageBegin('sell', TMessageType.CALL, self._seqid)
    args = sell_args()
    args.guarantee = guarantee
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sell(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sell_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.d is not None:
      raise result.d
    if result.t is not None:
      raise result.t
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sell failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["apikey"] = Processor.process_apikey
    self._processMap["login"] = Processor.process_login
    self._processMap["getArtist"] = Processor.process_getArtist
    self._processMap["getLightArtist"] = Processor.process_getLightArtist
    self._processMap["getArtistSE"] = Processor.process_getArtistSE
    self._processMap["getArtistLFM"] = Processor.process_getArtistLFM
    self._processMap["getArtistHistory"] = Processor.process_getArtistHistory
    self._processMap["searchArtist"] = Processor.process_searchArtist
    self._processMap["getSETop"] = Processor.process_getSETop
    self._processMap["getLFMTop"] = Processor.process_getLFMTop
    self._processMap["getTradedArtists"] = Processor.process_getTradedArtists
    self._processMap["getRecentTrades"] = Processor.process_getRecentTrades
    self._processMap["getUserData"] = Processor.process_getUserData
    self._processMap["getUserMoney"] = Processor.process_getUserMoney
    self._processMap["getTopUsers"] = Processor.process_getTopUsers
    self._processMap["getNearUsers"] = Processor.process_getNearUsers
    self._processMap["getGuarantee"] = Processor.process_getGuarantee
    self._processMap["buy"] = Processor.process_buy
    self._processMap["sell"] = Processor.process_sell

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_apikey(self, seqid, iprot, oprot):
    args = apikey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = apikey_result()
    result.success = self._handler.apikey()
    oprot.writeMessageBegin("apikey", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_login(self, seqid, iprot, oprot):
    args = login_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = login_result()
    try:
      result.success = self._handler.login(args.token)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("login", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtist(self, seqid, iprot, oprot):
    args = getArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtist_result()
    try:
      result.success = self._handler.getArtist(args.artist)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLightArtist(self, seqid, iprot, oprot):
    args = getLightArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLightArtist_result()
    try:
      result.success = self._handler.getLightArtist(args.artist)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getLightArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtistSE(self, seqid, iprot, oprot):
    args = getArtistSE_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtistSE_result()
    try:
      result.success = self._handler.getArtistSE(args.artist, args.user)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getArtistSE", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtistLFM(self, seqid, iprot, oprot):
    args = getArtistLFM_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtistLFM_result()
    try:
      result.success = self._handler.getArtistLFM(args.artist, args.user)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getArtistLFM", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtistHistory(self, seqid, iprot, oprot):
    args = getArtistHistory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtistHistory_result()
    try:
      result.success = self._handler.getArtistHistory(args.artist, args.n)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getArtistHistory", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_searchArtist(self, seqid, iprot, oprot):
    args = searchArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = searchArtist_result()
    try:
      result.success = self._handler.searchArtist(args.text, args.n, args.page)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("searchArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSETop(self, seqid, iprot, oprot):
    args = getSETop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSETop_result()
    try:
      result.success = self._handler.getSETop(args.n, args.trange)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getSETop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLFMTop(self, seqid, iprot, oprot):
    args = getLFMTop_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLFMTop_result()
    try:
      result.success = self._handler.getLFMTop(args.n)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getLFMTop", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTradedArtists(self, seqid, iprot, oprot):
    args = getTradedArtists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTradedArtists_result()
    try:
      result.success = self._handler.getTradedArtists(args.n)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getTradedArtists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRecentTrades(self, seqid, iprot, oprot):
    args = getRecentTrades_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRecentTrades_result()
    try:
      result.success = self._handler.getRecentTrades(args.n)
    except TransientError as t:
      result.t = t
    except AuthenticationError as a:
      result.a = a
    except DataError as d:
      result.d = d
    except ProgrammingError as p:
      result.p = p
    except ServiceError as s:
      result.s = s
    oprot.writeMessageBegin("getRecentTrades", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUserData(self, seqid, iprot, oprot):
    args = getUserData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserData_result()
    try:
      result.success = self._handler.getUserData(args.user)
    except DataError as d:
      result.d = d
    oprot.writeMessageBegin("getUserData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUserMoney(self, seqid, iprot, oprot):
    args = getUserMoney_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserMoney_result()
    try:
      result.success = self._handler.getUserMoney(args.user)
    except DataError as d:
      result.d = d
    oprot.writeMessageBegin("getUserMoney", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTopUsers(self, seqid, iprot, oprot):
    args = getTopUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTopUsers_result()
    try:
      result.success = self._handler.getTopUsers(args.n, args.league, args.trange)
    except DataError as d:
      result.d = d
    oprot.writeMessageBegin("getTopUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNearUsers(self, seqid, iprot, oprot):
    args = getNearUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNearUsers_result()
    try:
      result.success = self._handler.getNearUsers(args.user)
    except DataError as d:
      result.d = d
    oprot.writeMessageBegin("getNearUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGuarantee(self, seqid, iprot, oprot):
    args = getGuarantee_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGuarantee_result()
    try:
      result.success = self._handler.getGuarantee(args.artist, args.user)
    except DataError as d:
      result.d = d
    except TransientError as t:
      result.t = t
    oprot.writeMessageBegin("getGuarantee", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_buy(self, seqid, iprot, oprot):
    args = buy_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = buy_result()
    try:
      result.success = self._handler.buy(args.guarantee, args.user)
    except DataError as d:
      result.d = d
    except TransientError as t:
      result.t = t
    oprot.writeMessageBegin("buy", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sell(self, seqid, iprot, oprot):
    args = sell_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sell_result()
    try:
      result.success = self._handler.sell(args.guarantee, args.user)
    except DataError as d:
      result.d = d
    except TransientError as t:
      result.t = t
    oprot.writeMessageBegin("sell", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class apikey_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('apikey_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class apikey_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('apikey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_args(object):
  """
  Attributes:
   - token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
  )

  def __init__(self, token=None,):
    self.token = token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthUser, AuthUser.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthUser()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtist_args(object):
  """
  Attributes:
   - artist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
  )

  def __init__(self, artist=None,):
    self.artist = artist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtist_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtist_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Artist, Artist.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Artist()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLightArtist_args(object):
  """
  Attributes:
   - artist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
  )

  def __init__(self, artist=None,):
    self.artist = artist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLightArtist_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLightArtist_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Artist, Artist.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Artist()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLightArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistSE_args(object):
  """
  Attributes:
   - artist
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, artist=None, user=None,):
    self.artist = artist
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistSE_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistSE_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ArtistSE, ArtistSE.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ArtistSE()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistSE_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistLFM_args(object):
  """
  Attributes:
   - artist
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 2
  )

  def __init__(self, artist=None, user=None,):
    self.artist = artist
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistLFM_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistLFM_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ArtistLFM, ArtistLFM.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ArtistLFM()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistLFM_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistHistory_args(object):
  """
  Attributes:
   - artist
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
    (2, TType.I32, 'n', None, None, ), # 2
  )

  def __init__(self, artist=None, n=None,):
    self.artist = artist
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistHistory_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 2)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistHistory_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ArtistHistory, ArtistHistory.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ArtistHistory()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistHistory_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchArtist_args(object):
  """
  Attributes:
   - text
   - n
   - page
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.I32, 'n', None, None, ), # 2
    (3, TType.I32, 'page', None, None, ), # 3
  )

  def __init__(self, text=None, n=None, page=None,):
    self.text = text
    self.n = n
    self.page = page

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.page = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchArtist_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 2)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.page is not None:
      oprot.writeFieldBegin('page', TType.I32, 3)
      oprot.writeI32(self.page)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.text is None:
      raise TProtocol.TProtocolException(message='Required field text is unset!')
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.page is None:
      raise TProtocol.TProtocolException(message='Required field page is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchArtist_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Artist, Artist.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype70, _size67) = iprot.readListBegin()
          for _i71 in xrange(_size67):
            _elem72 = Artist()
            _elem72.read(iprot)
            self.success.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter73 in self.success:
        iter73.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSETop_args(object):
  """
  Attributes:
   - n
   - trange
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.I32, 'trange', None, None, ), # 2
  )

  def __init__(self, n=None, trange=None,):
    self.n = n
    self.trange = trange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.trange = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSETop_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.trange is not None:
      oprot.writeFieldBegin('trange', TType.I32, 2)
      oprot.writeI32(self.trange)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.trange is None:
      raise TProtocol.TProtocolException(message='Required field trange is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSETop_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Artist, Artist.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype77, _size74) = iprot.readListBegin()
          for _i78 in xrange(_size74):
            _elem79 = Artist()
            _elem79.read(iprot)
            self.success.append(_elem79)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSETop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter80 in self.success:
        iter80.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLFMTop_args(object):
  """
  Attributes:
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
  )

  def __init__(self, n=None,):
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLFMTop_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLFMTop_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Artist, Artist.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype84, _size81) = iprot.readListBegin()
          for _i85 in xrange(_size81):
            _elem86 = Artist()
            _elem86.read(iprot)
            self.success.append(_elem86)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLFMTop_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter87 in self.success:
        iter87.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTradedArtists_args(object):
  """
  Attributes:
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
  )

  def __init__(self, n=None,):
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTradedArtists_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTradedArtists_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Artist, Artist.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype91, _size88) = iprot.readListBegin()
          for _i92 in xrange(_size88):
            _elem93 = Artist()
            _elem93.read(iprot)
            self.success.append(_elem93)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTradedArtists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter94 in self.success:
        iter94.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecentTrades_args(object):
  """
  Attributes:
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
  )

  def __init__(self, n=None,):
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecentTrades_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecentTrades_result(object):
  """
  Attributes:
   - success
   - t
   - a
   - d
   - p
   - s
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Artist, Artist.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'a', (AuthenticationError, AuthenticationError.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'p', (ProgrammingError, ProgrammingError.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 's', (ServiceError, ServiceError.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, t=None, a=None, d=None, p=None, s=None,):
    self.success = success
    self.t = t
    self.a = a
    self.d = d
    self.p = p
    self.s = s

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype98, _size95) = iprot.readListBegin()
          for _i99 in xrange(_size95):
            _elem100 = Artist()
            _elem100.read(iprot)
            self.success.append(_elem100)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.a = AuthenticationError()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.p = ProgrammingError()
          self.p.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.s = ServiceError()
          self.s.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecentTrades_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter101 in self.success:
        iter101.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 1)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    if self.a is not None:
      oprot.writeFieldBegin('a', TType.STRUCT, 2)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 3)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.p is not None:
      oprot.writeFieldBegin('p', TType.STRUCT, 4)
      self.p.write(oprot)
      oprot.writeFieldEnd()
    if self.s is not None:
      oprot.writeFieldBegin('s', TType.STRUCT, 5)
      self.s.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserData_args(object):
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user', None, None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserData_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserData_result(object):
  """
  Attributes:
   - success
   - d
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserData, UserData.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, d=None,):
    self.success = success
    self.d = d

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserData()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserMoney_args(object):
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserMoney_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 1)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserMoney_result(object):
  """
  Attributes:
   - success
   - d
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthUser, AuthUser.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, d=None,):
    self.success = success
    self.d = d

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthUser()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserMoney_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopUsers_args(object):
  """
  Attributes:
   - n
   - league
   - trange
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.STRUCT, 'league', (League, League.thrift_spec), None, ), # 2
    (3, TType.I32, 'trange', None, None, ), # 3
  )

  def __init__(self, n=None, league=None, trange=None,):
    self.n = n
    self.league = league
    self.trange = trange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.league = League()
          self.league.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.trange = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopUsers_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.league is not None:
      oprot.writeFieldBegin('league', TType.STRUCT, 2)
      self.league.write(oprot)
      oprot.writeFieldEnd()
    if self.trange is not None:
      oprot.writeFieldBegin('trange', TType.I32, 3)
      oprot.writeI32(self.trange)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.league is None:
      raise TProtocol.TProtocolException(message='Required field league is unset!')
    if self.trange is None:
      raise TProtocol.TProtocolException(message='Required field trange is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopUsers_result(object):
  """
  Attributes:
   - success
   - d
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserLeaderboard, UserLeaderboard.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, d=None,):
    self.success = success
    self.d = d

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserLeaderboard()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNearUsers_args(object):
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user', None, None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNearUsers_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNearUsers_result(object):
  """
  Attributes:
   - success
   - d
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserLeaderboard, UserLeaderboard.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, d=None,):
    self.success = success
    self.d = d

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserLeaderboard()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNearUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGuarantee_args(object):
  """
  Attributes:
   - artist
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 2
  )

  def __init__(self, artist=None, user=None,):
    self.artist = artist
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGuarantee_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGuarantee_result(object):
  """
  Attributes:
   - success
   - d
   - t
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Guarantee, Guarantee.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, d=None, t=None,):
    self.success = success
    self.d = d
    self.t = t

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Guarantee()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGuarantee_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 2)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class buy_args(object):
  """
  Attributes:
   - guarantee
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'guarantee', (Guarantee, Guarantee.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 2
  )

  def __init__(self, guarantee=None, user=None,):
    self.guarantee = guarantee
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.guarantee = Guarantee()
          self.guarantee.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('buy_args')
    if self.guarantee is not None:
      oprot.writeFieldBegin('guarantee', TType.STRUCT, 1)
      self.guarantee.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.guarantee is None:
      raise TProtocol.TProtocolException(message='Required field guarantee is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class buy_result(object):
  """
  Attributes:
   - success
   - d
   - t
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, d=None, t=None,):
    self.success = success
    self.d = d
    self.t = t

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('buy_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 2)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sell_args(object):
  """
  Attributes:
   - guarantee
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'guarantee', (Guarantee, Guarantee.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (AuthUser, AuthUser.thrift_spec), None, ), # 2
  )

  def __init__(self, guarantee=None, user=None,):
    self.guarantee = guarantee
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.guarantee = Guarantee()
          self.guarantee.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = AuthUser()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sell_args')
    if self.guarantee is not None:
      oprot.writeFieldBegin('guarantee', TType.STRUCT, 1)
      self.guarantee.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.guarantee is None:
      raise TProtocol.TProtocolException(message='Required field guarantee is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sell_result(object):
  """
  Attributes:
   - success
   - d
   - t
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'd', (DataError, DataError.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 't', (TransientError, TransientError.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, d=None, t=None,):
    self.success = success
    self.d = d
    self.t = t

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.d = DataError()
          self.d.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.t = TransientError()
          self.t.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sell_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.d is not None:
      oprot.writeFieldBegin('d', TType.STRUCT, 1)
      self.d.write(oprot)
      oprot.writeFieldEnd()
    if self.t is not None:
      oprot.writeFieldBegin('t', TType.STRUCT, 2)
      self.t.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

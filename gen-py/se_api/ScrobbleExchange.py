#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def login(self, token):
    """
    If successful, returns a User object with their name and session token.
    If not, returns an AuthException. AccountException is returned if
    account data is incorrect or doesn't exist, and should be handled
    appropriately

    Parameters:
     - token
    """
    pass

  def getArtist(self, artist):
    """
    Returns basic artist info. Artist string can be either the name, or the
    musicbrainz ID

    Parameters:
     - artist
    """
    pass

  def getArtistSE(self, artist):
    """
    Returns the data from our db for the artist.
    Assumes that if artist isn't in the DB, then it gets pulled in
    on-demand and so will always return some data.
    Artist string can be either the name, or the musicbrainz ID

    Parameters:
     - artist
    """
    pass

  def getArtistLFM(self, artist):
    """
    Returns the contextual artist info from last.fm for the artist
    Artist string can be either the name or the musicbrainz ID

    Parameters:
     - artist
    """
    pass

  def searchArtist(self, text):
    """
    returns a list of possible artists from a partial string. Ordered by
    decreasing relevance. List size is limited to 5 elements.

    Parameters:
     - text
    """
    pass

  def getTopArtists(self, n, tag):
    """
    Returns a list of the n top artists by decreasing value. By default, tag
    should have a value of '' and only be used if you want to limit the
    top lists to a certain tag.

    Parameters:
     - n
     - tag
    """
    pass

  def getTradedArtists(self, n):
    """
    Returns a list of the n most traded artists by decreasing value.

    Parameters:
     - n
    """
    pass

  def getUserData(self, user):
    """
    Returns extended user data. User string must be the username of the
    user whose data you wish to return

    Parameters:
     - user
    """
    pass

  def getTopUsers(self, n, league):
    """
    Returns the n top users by decreasing value in the given league.

    Parameters:
     - n
     - league
    """
    pass

  def getNearUsers(self, user):
    """
    Returns a list of 10 users with 4 above and 5 below in the leaderboard
    compared to the user provided

    Parameters:
     - user
    """
    pass

  def getTransaction(self, artist):
    """
    Returns the guarantee token to the front end

    Parameters:
     - artist
    """
    pass

  def buyArtist(self, transaction, user):
    """
    Buys artist for user, and returns the new value of that stock in the
    game. Throws a transaction exception if something goes wrong while
    buying or the user can't afford to buy the artist.
    Throws user exception if the user already owns the stock

    Parameters:
     - transaction
     - user
    """
    pass

  def sellArtist(self, transaction, user):
    """
    Sells artist for user, and returns the new value of that artist. User
    exception is thrown if the user isn't allowed to sell or doesn't own
    that artist

    Parameters:
     - transaction
     - user
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def login(self, token):
    """
    If successful, returns a User object with their name and session token.
    If not, returns an AuthException. AccountException is returned if
    account data is incorrect or doesn't exist, and should be handled
    appropriately

    Parameters:
     - token
    """
    self.send_login(token)
    return self.recv_login()

  def send_login(self, token):
    self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
    args = login_args()
    args.token = token
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_login(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = login_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.authexp is not None:
      raise result.authexp
    if result.accexp is not None:
      raise result.accexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result");

  def getArtist(self, artist):
    """
    Returns basic artist info. Artist string can be either the name, or the
    musicbrainz ID

    Parameters:
     - artist
    """
    self.send_getArtist(artist)
    return self.recv_getArtist()

  def send_getArtist(self, artist):
    self._oprot.writeMessageBegin('getArtist', TMessageType.CALL, self._seqid)
    args = getArtist_args()
    args.artist = artist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.searchexp is not None:
      raise result.searchexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtist failed: unknown result");

  def getArtistSE(self, artist):
    """
    Returns the data from our db for the artist.
    Assumes that if artist isn't in the DB, then it gets pulled in
    on-demand and so will always return some data.
    Artist string can be either the name, or the musicbrainz ID

    Parameters:
     - artist
    """
    self.send_getArtistSE(artist)
    return self.recv_getArtistSE()

  def send_getArtistSE(self, artist):
    self._oprot.writeMessageBegin('getArtistSE', TMessageType.CALL, self._seqid)
    args = getArtistSE_args()
    args.artist = artist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtistSE(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtistSE_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.searchexp is not None:
      raise result.searchexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtistSE failed: unknown result");

  def getArtistLFM(self, artist):
    """
    Returns the contextual artist info from last.fm for the artist
    Artist string can be either the name or the musicbrainz ID

    Parameters:
     - artist
    """
    self.send_getArtistLFM(artist)
    return self.recv_getArtistLFM()

  def send_getArtistLFM(self, artist):
    self._oprot.writeMessageBegin('getArtistLFM', TMessageType.CALL, self._seqid)
    args = getArtistLFM_args()
    args.artist = artist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getArtistLFM(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getArtistLFM_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.searchexp is not None:
      raise result.searchexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getArtistLFM failed: unknown result");

  def searchArtist(self, text):
    """
    returns a list of possible artists from a partial string. Ordered by
    decreasing relevance. List size is limited to 5 elements.

    Parameters:
     - text
    """
    self.send_searchArtist(text)
    return self.recv_searchArtist()

  def send_searchArtist(self, text):
    self._oprot.writeMessageBegin('searchArtist', TMessageType.CALL, self._seqid)
    args = searchArtist_args()
    args.text = text
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_searchArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = searchArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.searchexp is not None:
      raise result.searchexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "searchArtist failed: unknown result");

  def getTopArtists(self, n, tag):
    """
    Returns a list of the n top artists by decreasing value. By default, tag
    should have a value of '' and only be used if you want to limit the
    top lists to a certain tag.

    Parameters:
     - n
     - tag
    """
    self.send_getTopArtists(n, tag)
    return self.recv_getTopArtists()

  def send_getTopArtists(self, n, tag):
    self._oprot.writeMessageBegin('getTopArtists', TMessageType.CALL, self._seqid)
    args = getTopArtists_args()
    args.n = n
    args.tag = tag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTopArtists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTopArtists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTopArtists failed: unknown result");

  def getTradedArtists(self, n):
    """
    Returns a list of the n most traded artists by decreasing value.

    Parameters:
     - n
    """
    self.send_getTradedArtists(n)
    return self.recv_getTradedArtists()

  def send_getTradedArtists(self, n):
    self._oprot.writeMessageBegin('getTradedArtists', TMessageType.CALL, self._seqid)
    args = getTradedArtists_args()
    args.n = n
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTradedArtists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTradedArtists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTradedArtists failed: unknown result");

  def getUserData(self, user):
    """
    Returns extended user data. User string must be the username of the
    user whose data you wish to return

    Parameters:
     - user
    """
    self.send_getUserData(user)
    return self.recv_getUserData()

  def send_getUserData(self, user):
    self._oprot.writeMessageBegin('getUserData', TMessageType.CALL, self._seqid)
    args = getUserData_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUserData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUserData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uexp is not None:
      raise result.uexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserData failed: unknown result");

  def getTopUsers(self, n, league):
    """
    Returns the n top users by decreasing value in the given league.

    Parameters:
     - n
     - league
    """
    self.send_getTopUsers(n, league)
    return self.recv_getTopUsers()

  def send_getTopUsers(self, n, league):
    self._oprot.writeMessageBegin('getTopUsers', TMessageType.CALL, self._seqid)
    args = getTopUsers_args()
    args.n = n
    args.league = league
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTopUsers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTopUsers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uexp is not None:
      raise result.uexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTopUsers failed: unknown result");

  def getNearUsers(self, user):
    """
    Returns a list of 10 users with 4 above and 5 below in the leaderboard
    compared to the user provided

    Parameters:
     - user
    """
    self.send_getNearUsers(user)
    return self.recv_getNearUsers()

  def send_getNearUsers(self, user):
    self._oprot.writeMessageBegin('getNearUsers', TMessageType.CALL, self._seqid)
    args = getNearUsers_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNearUsers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNearUsers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.uexp is not None:
      raise result.uexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNearUsers failed: unknown result");

  def getTransaction(self, artist):
    """
    Returns the guarantee token to the front end

    Parameters:
     - artist
    """
    self.send_getTransaction(artist)
    return self.recv_getTransaction()

  def send_getTransaction(self, artist):
    self._oprot.writeMessageBegin('getTransaction', TMessageType.CALL, self._seqid)
    args = getTransaction_args()
    args.artist = artist
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTransaction(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTransaction_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.transexp is not None:
      raise result.transexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTransaction failed: unknown result");

  def buyArtist(self, transaction, user):
    """
    Buys artist for user, and returns the new value of that stock in the
    game. Throws a transaction exception if something goes wrong while
    buying or the user can't afford to buy the artist.
    Throws user exception if the user already owns the stock

    Parameters:
     - transaction
     - user
    """
    self.send_buyArtist(transaction, user)
    return self.recv_buyArtist()

  def send_buyArtist(self, transaction, user):
    self._oprot.writeMessageBegin('buyArtist', TMessageType.CALL, self._seqid)
    args = buyArtist_args()
    args.transaction = transaction
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_buyArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = buyArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.transexp is not None:
      raise result.transexp
    if result.userexp is not None:
      raise result.userexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "buyArtist failed: unknown result");

  def sellArtist(self, transaction, user):
    """
    Sells artist for user, and returns the new value of that artist. User
    exception is thrown if the user isn't allowed to sell or doesn't own
    that artist

    Parameters:
     - transaction
     - user
    """
    self.send_sellArtist(transaction, user)
    return self.recv_sellArtist()

  def send_sellArtist(self, transaction, user):
    self._oprot.writeMessageBegin('sellArtist', TMessageType.CALL, self._seqid)
    args = sellArtist_args()
    args.transaction = transaction
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sellArtist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sellArtist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.transexp is not None:
      raise result.transexp
    if result.userexp is not None:
      raise result.userexp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sellArtist failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["login"] = Processor.process_login
    self._processMap["getArtist"] = Processor.process_getArtist
    self._processMap["getArtistSE"] = Processor.process_getArtistSE
    self._processMap["getArtistLFM"] = Processor.process_getArtistLFM
    self._processMap["searchArtist"] = Processor.process_searchArtist
    self._processMap["getTopArtists"] = Processor.process_getTopArtists
    self._processMap["getTradedArtists"] = Processor.process_getTradedArtists
    self._processMap["getUserData"] = Processor.process_getUserData
    self._processMap["getTopUsers"] = Processor.process_getTopUsers
    self._processMap["getNearUsers"] = Processor.process_getNearUsers
    self._processMap["getTransaction"] = Processor.process_getTransaction
    self._processMap["buyArtist"] = Processor.process_buyArtist
    self._processMap["sellArtist"] = Processor.process_sellArtist

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_login(self, seqid, iprot, oprot):
    args = login_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = login_result()
    try:
      result.success = self._handler.login(args.token)
    except AuthException as authexp:
      result.authexp = authexp
    except AccountException as accexp:
      result.accexp = accexp
    oprot.writeMessageBegin("login", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtist(self, seqid, iprot, oprot):
    args = getArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtist_result()
    try:
      result.success = self._handler.getArtist(args.artist)
    except SearchException as searchexp:
      result.searchexp = searchexp
    oprot.writeMessageBegin("getArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtistSE(self, seqid, iprot, oprot):
    args = getArtistSE_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtistSE_result()
    try:
      result.success = self._handler.getArtistSE(args.artist)
    except SearchException as searchexp:
      result.searchexp = searchexp
    oprot.writeMessageBegin("getArtistSE", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getArtistLFM(self, seqid, iprot, oprot):
    args = getArtistLFM_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getArtistLFM_result()
    try:
      result.success = self._handler.getArtistLFM(args.artist)
    except SearchException as searchexp:
      result.searchexp = searchexp
    oprot.writeMessageBegin("getArtistLFM", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_searchArtist(self, seqid, iprot, oprot):
    args = searchArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = searchArtist_result()
    try:
      result.success = self._handler.searchArtist(args.text)
    except SearchException as searchexp:
      result.searchexp = searchexp
    oprot.writeMessageBegin("searchArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTopArtists(self, seqid, iprot, oprot):
    args = getTopArtists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTopArtists_result()
    result.success = self._handler.getTopArtists(args.n, args.tag)
    oprot.writeMessageBegin("getTopArtists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTradedArtists(self, seqid, iprot, oprot):
    args = getTradedArtists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTradedArtists_result()
    result.success = self._handler.getTradedArtists(args.n)
    oprot.writeMessageBegin("getTradedArtists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUserData(self, seqid, iprot, oprot):
    args = getUserData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUserData_result()
    try:
      result.success = self._handler.getUserData(args.user)
    except UserException as uexp:
      result.uexp = uexp
    oprot.writeMessageBegin("getUserData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTopUsers(self, seqid, iprot, oprot):
    args = getTopUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTopUsers_result()
    try:
      result.success = self._handler.getTopUsers(args.n, args.league)
    except UserException as uexp:
      result.uexp = uexp
    oprot.writeMessageBegin("getTopUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNearUsers(self, seqid, iprot, oprot):
    args = getNearUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNearUsers_result()
    try:
      result.success = self._handler.getNearUsers(args.user)
    except UserException as uexp:
      result.uexp = uexp
    oprot.writeMessageBegin("getNearUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTransaction(self, seqid, iprot, oprot):
    args = getTransaction_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTransaction_result()
    try:
      result.success = self._handler.getTransaction(args.artist)
    except TransactionException as transexp:
      result.transexp = transexp
    oprot.writeMessageBegin("getTransaction", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_buyArtist(self, seqid, iprot, oprot):
    args = buyArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = buyArtist_result()
    try:
      result.success = self._handler.buyArtist(args.transaction, args.user)
    except TransactionException as transexp:
      result.transexp = transexp
    except UserException as userexp:
      result.userexp = userexp
    oprot.writeMessageBegin("buyArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sellArtist(self, seqid, iprot, oprot):
    args = sellArtist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sellArtist_result()
    try:
      result.success = self._handler.sellArtist(args.transaction, args.user)
    except TransactionException as transexp:
      result.transexp = transexp
    except UserException as userexp:
      result.userexp = userexp
    oprot.writeMessageBegin("sellArtist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class login_args(object):
  """
  Attributes:
   - token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token', None, None, ), # 1
  )

  def __init__(self, token=None,):
    self.token = token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 1)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_result(object):
  """
  Attributes:
   - success
   - authexp
   - accexp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (User, User.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'authexp', (AuthException, AuthException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'accexp', (AccountException, AccountException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, authexp=None, accexp=None,):
    self.success = success
    self.authexp = authexp
    self.accexp = accexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = User()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.authexp = AuthException()
          self.authexp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.accexp = AccountException()
          self.accexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.authexp is not None:
      oprot.writeFieldBegin('authexp', TType.STRUCT, 1)
      self.authexp.write(oprot)
      oprot.writeFieldEnd()
    if self.accexp is not None:
      oprot.writeFieldBegin('accexp', TType.STRUCT, 2)
      self.accexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtist_args(object):
  """
  Attributes:
   - artist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
  )

  def __init__(self, artist=None,):
    self.artist = artist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtist_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtist_result(object):
  """
  Attributes:
   - success
   - searchexp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Artist, Artist.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'searchexp', (SearchException, SearchException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, searchexp=None,):
    self.success = success
    self.searchexp = searchexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Artist()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.searchexp = SearchException()
          self.searchexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.searchexp is not None:
      oprot.writeFieldBegin('searchexp', TType.STRUCT, 1)
      self.searchexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistSE_args(object):
  """
  Attributes:
   - artist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
  )

  def __init__(self, artist=None,):
    self.artist = artist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistSE_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistSE_result(object):
  """
  Attributes:
   - success
   - searchexp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ArtistSE, ArtistSE.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'searchexp', (SearchException, SearchException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, searchexp=None,):
    self.success = success
    self.searchexp = searchexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ArtistSE()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.searchexp = SearchException()
          self.searchexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistSE_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.searchexp is not None:
      oprot.writeFieldBegin('searchexp', TType.STRUCT, 1)
      self.searchexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistLFM_args(object):
  """
  Attributes:
   - artist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
  )

  def __init__(self, artist=None,):
    self.artist = artist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistLFM_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getArtistLFM_result(object):
  """
  Attributes:
   - success
   - searchexp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ArtistLFM, ArtistLFM.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'searchexp', (SearchException, SearchException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, searchexp=None,):
    self.success = success
    self.searchexp = searchexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ArtistLFM()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.searchexp = SearchException()
          self.searchexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getArtistLFM_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.searchexp is not None:
      oprot.writeFieldBegin('searchexp', TType.STRUCT, 1)
      self.searchexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchArtist_args(object):
  """
  Attributes:
   - text
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
  )

  def __init__(self, text=None,):
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchArtist_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.text is None:
      raise TProtocol.TProtocolException(message='Required field text is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchArtist_result(object):
  """
  Attributes:
   - success
   - searchexp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Artist, Artist.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'searchexp', (SearchException, SearchException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, searchexp=None,):
    self.success = success
    self.searchexp = searchexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype56, _size53) = iprot.readListBegin()
          for _i57 in xrange(_size53):
            _elem58 = Artist()
            _elem58.read(iprot)
            self.success.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.searchexp = SearchException()
          self.searchexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter59 in self.success:
        iter59.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searchexp is not None:
      oprot.writeFieldBegin('searchexp', TType.STRUCT, 1)
      self.searchexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopArtists_args(object):
  """
  Attributes:
   - n
   - tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.STRING, 'tag', None, None, ), # 2
  )

  def __init__(self, n=None, tag=None,):
    self.n = n
    self.tag = tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopArtists_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRING, 2)
      oprot.writeString(self.tag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopArtists_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Artist, Artist.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in xrange(_size60):
            _elem65 = Artist()
            _elem65.read(iprot)
            self.success.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopArtists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter66 in self.success:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTradedArtists_args(object):
  """
  Attributes:
   - n
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
  )

  def __init__(self, n=None,):
    self.n = n

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTradedArtists_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTradedArtists_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Artist, Artist.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype70, _size67) = iprot.readListBegin()
          for _i71 in xrange(_size67):
            _elem72 = Artist()
            _elem72.read(iprot)
            self.success.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTradedArtists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter73 in self.success:
        iter73.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserData_args(object):
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user', None, None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserData_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUserData_result(object):
  """
  Attributes:
   - success
   - uexp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (UserData, UserData.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'uexp', (UserException, UserException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, uexp=None,):
    self.success = success
    self.uexp = uexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = UserData()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uexp = UserException()
          self.uexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUserData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.uexp is not None:
      oprot.writeFieldBegin('uexp', TType.STRUCT, 1)
      self.uexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopUsers_args(object):
  """
  Attributes:
   - n
   - league
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'n', None, None, ), # 1
    (2, TType.STRING, 'league', None, None, ), # 2
  )

  def __init__(self, n=None, league=None,):
    self.n = n
    self.league = league

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.n = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.league = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopUsers_args')
    if self.n is not None:
      oprot.writeFieldBegin('n', TType.I32, 1)
      oprot.writeI32(self.n)
      oprot.writeFieldEnd()
    if self.league is not None:
      oprot.writeFieldBegin('league', TType.STRING, 2)
      oprot.writeString(self.league)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.n is None:
      raise TProtocol.TProtocolException(message='Required field n is unset!')
    if self.league is None:
      raise TProtocol.TProtocolException(message='Required field league is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTopUsers_result(object):
  """
  Attributes:
   - success
   - uexp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(User, User.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'uexp', (UserException, UserException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, uexp=None,):
    self.success = success
    self.uexp = uexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype77, _size74) = iprot.readListBegin()
          for _i78 in xrange(_size74):
            _elem79 = User()
            _elem79.read(iprot)
            self.success.append(_elem79)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uexp = UserException()
          self.uexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTopUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter80 in self.success:
        iter80.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.uexp is not None:
      oprot.writeFieldBegin('uexp', TType.STRUCT, 1)
      self.uexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNearUsers_args(object):
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user', None, None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNearUsers_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNearUsers_result(object):
  """
  Attributes:
   - success
   - uexp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(User, User.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'uexp', (UserException, UserException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, uexp=None,):
    self.success = success
    self.uexp = uexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype84, _size81) = iprot.readListBegin()
          for _i85 in xrange(_size81):
            _elem86 = User()
            _elem86.read(iprot)
            self.success.append(_elem86)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.uexp = UserException()
          self.uexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNearUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter87 in self.success:
        iter87.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.uexp is not None:
      oprot.writeFieldBegin('uexp', TType.STRUCT, 1)
      self.uexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTransaction_args(object):
  """
  Attributes:
   - artist
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'artist', (Artist, Artist.thrift_spec), None, ), # 1
  )

  def __init__(self, artist=None,):
    self.artist = artist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.artist = Artist()
          self.artist.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTransaction_args')
    if self.artist is not None:
      oprot.writeFieldBegin('artist', TType.STRUCT, 1)
      self.artist.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.artist is None:
      raise TProtocol.TProtocolException(message='Required field artist is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTransaction_result(object):
  """
  Attributes:
   - success
   - transexp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Transaction, Transaction.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'transexp', (TransactionException, TransactionException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, transexp=None,):
    self.success = success
    self.transexp = transexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Transaction()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.transexp = TransactionException()
          self.transexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTransaction_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.transexp is not None:
      oprot.writeFieldBegin('transexp', TType.STRUCT, 1)
      self.transexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class buyArtist_args(object):
  """
  Attributes:
   - transaction
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'transaction', (Transaction, Transaction.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, transaction=None, user=None,):
    self.transaction = transaction
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.transaction = Transaction()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('buyArtist_args')
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 1)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.transaction is None:
      raise TProtocol.TProtocolException(message='Required field transaction is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class buyArtist_result(object):
  """
  Attributes:
   - success
   - transexp
   - userexp
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'transexp', (TransactionException, TransactionException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'userexp', (UserException, UserException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, transexp=None, userexp=None,):
    self.success = success
    self.transexp = transexp
    self.userexp = userexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.transexp = TransactionException()
          self.transexp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.userexp = UserException()
          self.userexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('buyArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.transexp is not None:
      oprot.writeFieldBegin('transexp', TType.STRUCT, 1)
      self.transexp.write(oprot)
      oprot.writeFieldEnd()
    if self.userexp is not None:
      oprot.writeFieldBegin('userexp', TType.STRUCT, 2)
      self.userexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sellArtist_args(object):
  """
  Attributes:
   - transaction
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'transaction', (Transaction, Transaction.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, transaction=None, user=None,):
    self.transaction = transaction
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.transaction = Transaction()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sellArtist_args')
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 1)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.transaction is None:
      raise TProtocol.TProtocolException(message='Required field transaction is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sellArtist_result(object):
  """
  Attributes:
   - success
   - transexp
   - userexp
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'transexp', (TransactionException, TransactionException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'userexp', (UserException, UserException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, transexp=None, userexp=None,):
    self.success = success
    self.transexp = transexp
    self.userexp = userexp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.transexp = TransactionException()
          self.transexp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.userexp = UserException()
          self.userexp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sellArtist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.transexp is not None:
      oprot.writeFieldBegin('transexp', TType.STRUCT, 1)
      self.transexp.write(oprot)
      oprot.writeFieldEnd()
    if self.userexp is not None:
      oprot.writeFieldBegin('userexp', TType.STRUCT, 2)
      self.userexp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
